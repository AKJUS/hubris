:toc:

= Interrupts in Hubris

This document discusses the role of CPU interrupts in Hubris and applications
built atop it.

== Interrupts vs Exceptions

We distinguish between *interrupts* and *exceptions*. (This is ARM terminology,
but it's a general idea.)

An _exception_ is generated by the processor in response to something about the
program. This would include memory access violations, illegal instructions,
privilege violations, bus faults, system calls, etc. Exceptions may be
asynchronous but are often synchronous.

An _interrupt_ is generated by a peripheral to signal an asynchronous event.

The kernel handles both interrupts and exceptions, but they can be routed to
tasks, using slightly different mechanisms.

== The Hubris interrupt model

We assume an interrupt system with the following characteristics. This is based
on the design of the ARMv7-M interrupt system, but is intended to be general.

- Interrupts can be numbered using small integers starting at zero. (They may
  start above zero in the hardware -- for example, on ARMv7-M, "interrupts" 0-15
  are exceptions -- but as long as we know that offset it's fine.)

- Interrupts have a "pending" flag and an "enable" flag. The pending flag can be
  set by hardware at any time, but the ISR will only be invoked if the enable
  and pending flags are set at the same time. (This ensures that momentary
  events are latched and can be handled with a delay.) Starting the interrupt
  service routine clears the "pending" flag and may or may not affect the
  "enable" flag.

- Interrupt handlers can be configured not to preempt one another or the kernel,
  either using static priorities or using explicit critical sections.  If an
  interrupt arrives while an ISR is running, or while the kernel is processing a
  syscall, it remains pending until the current ISR returns.

For brevity in the discussion below, we'll refer to an interrupt "happening" as
when the CPU decides to execute the associated in-kernel interrupt service
routine. That can occur when...

- The `pending` bit is set while `enable` was already set.
- The `enable` bit is set when `pending` was previously set.

== Routing interrupts to tasks

Each implemented interrupt has two pieces of information recorded in a table:

- A task index.
- A notification set.

Both are statically configured by `interrupts` routing keys in the configuration
TOML.

NOTE: Typically an SoC will have many interrupts that are not used by a given
application. We currently store interrupt response information only for the
interrupts that are being used, at some cost in response time.

When an interrupt happens, the kernel ISR will find the task named in the
response record, and post the notification set. The kernel then clears the
interrupt's `enable` bit to prevent reoccurrence until the task has a chance to
erspond.

The task is expected to

1. Notice that the notification was posted, when convenient.
2. Interact with the hardware to resolve the interrupt condition.
3. Call into the kernel to re-enable the interrupt, if desired, using the
`irq_control` syscall.

When a task starts or restarts, the kernel ensures that its associated
interrupts are disabled. To begin receiving notifications on interrupts, the
task must enable the interrupts using `irq_control`.

The actual hardware interrupt number is hidden from tasks -- tasks only see
their particular set of notification bits being posted. This raises the question
of how a task should specify the interrupt(s) to enable when calling
`irq_control`. We repurpose the notification bits: the task hands the kernel the
notification set (typically, one bit set) that corresponds to the interrupt it
wishes to enable or disable. This prevents a defective task from messing with
others' interrupts, without the need to build additional security.

== Kernel reserved interrupts

Some interrupts on some systems cannot be reasonably handled outside the kernel.
In these cases, the kernel will handle them directly, and provide abstractions
if necessary.

The main example here is the system tick timer that is used to maintain the
kernel's internal sense of time, but DMA controllers might also fall into this
category.
